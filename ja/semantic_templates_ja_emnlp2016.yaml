##### Semantic templates for Japanese with Neo-Davidsonian event semantics ##### 

## Basic logical form:
## x-ga y-o E-suru \C1 C2 K. exists v. (K(E,v) & C1(x,v,Top) & C2(y,v,Acc))
##
## Alternative:
## \C1 C2 K. exists v. (E(v) & C1(x,v,Top) & C2(y,v,Acc) & K(v))
##
## Type T ::= Entity | Event | Prop | T -> T
## 
## Variable     Type
## x,y,z,x1,x2  Entity, E
## v,v1,v2      Event, Ev
## F,G,F1,F2    E -> Prop
## J,J1,J2      Ev -> Prop
## N,N1,N2      (E -> Prop) -> E -> Prop (= Nmod)
## K,K1,K2      (Ev -> Prop) -> Ev -> Prop (= Vmod)
## Q,Q1,Q2      Nmod -> (E -> Prop) -> Prop (= NP*)
## C1,C2        Entity -> Event -> (Event -> Entity) -> Prop (= Role)
## S,S1,S2      Role -> Role -> Vmod -> Prop (= S*)
## V1           (Nmod -> (E -> Prop) -> Prop) -> Role -> Role -> Vmod -> Prop (= NP* -> S*)
## V2           (Nmod -> (E -> Prop) -> Prop) -> (Nmod -> (E -> Prop) -> Prop) -> Role -> Role -> Vmod -> Prop (= NP* -> NP* -> S*)
## E            expression (surface form)
##
## Constant          Type
## Top,Acc,Dat,Attr  Event -> Entity
## AccI              Event -> Prop -> Prop
##

# Cat      Term : Type
# S        \C1 C2 K. exists v. K(E,v) : Role -> Role -> Vmod -> Prop (= S*)
# NP       \N F. Det(\x.N(E,x), F) : NMod -> (E -> Prop) -> Prop (= NP*)
# S\NP     \Q C1 C2 K. exists v. Q(\I.I, \x.exists v.(K(E,v) & C1(x,v,Top))) : NP* -> S*
# S\NP\NP  \Q1 Q2 C1 C2 K. exists v. Q2(\I.I, \y.Q1(\I.I, \x.exists v.(K(E,v) & C1(x,v,Top) & C2(y,v,Acc)))) : NP* -> NP* -> S*
# S/S      \S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & E(v2)),v1) : S* -> S* (extensional modification)
# S/S      \S C1 C2 K. S(C1,C2,\J v.K(E(J),v)) : S* -> S* (intensional modification)
# NP/NP    \Q N F. Q(\G x. N(\y.(E(y) & G(y)),x), F) : NP* -> NP* (extensional modification)
# NP/NP    \Q N F. Q(\G x. N(E(G),x), F) : NP* -> NP* (intensional modification)


# Alternative??
# S        \K y. exists v.(E(v) & K(v,y)) : (Ev -> Prop) -> E -> Prop (= S*)
# jsem-56 (S/Sに広いスコープをもたせたい)

## Rule中のアルファベット：
## L := Left child node
## R := Right child node 
##################################################################


############### Unary lexical rule #################

# S\NP ==> NP/NP 
- category: NP/NP
  rule: ADNint
  child0_category: S\NP
  semantics: \V1 Q N F. Q(\G.N(\y.(G(y) & V1(\G1 G2.G2(y), \x v T.(T(v) = x), \x v T.(T(v) = x), \I.I))), F)

# S ==> NP/NP
- category: NP/NP
  rule: ADNext
  semantics: \S Q N F. Q(\I.I, \x.(Content(x,\K.S(\x v T.(T(v) = x), \x v T.(T(v) = x),K)) & F(x)))
  # semantics: \S Q N F. Q(\G.N(\x.(G(x) & (S(\x v T.(T(v) = x), \x v T.(T(v) = x), \J v.(J(v) & ((Top(v) = x))))))), F)

# S ==> NP/NP
- category: NP/NP
  rule: ADNext
  semantics: \S Q N F. Q(\G.N(\x.(G(x) & (S(\x v T.(T(v) = x), \x v T.(T(v) = x), \J v.(J(v) & ((Top(v) = x))))))), F)
  child0_any_category: S\NP[case=nc]
  # child0_any_base: だ
  # necessary for jsem-172,173,174
  # jsem-780,785

# S ==> NP/NP
- category: NP/NP
  rule: ADNext
  semantics: \S Q N F. Q(\G.N(\x.(G(x) & (S(\x v T.(T(v) = x), \x v T.(T(v) = x), \J v.(J(v) & ((Top(v) = x))))))), F)
  child0_any_pos: "形容詞"
  # child0_any_category: S\NP
  # jsem-101,102,103

# S ==> NP/NP
- category: NP/NP
  rule: ADNext
  semantics: \S Q N F. Q(\G.N(\x.(G(x) & (S(\x v T.(T(v) = x), \x v T.(T(v) = x), \J v.(J(v) & ((Top(v) = x))))))), F)
  child0_any_category: S\S[form=da]
  # child0_any_base: だ
  # jsem-053,054

## 強いルール
# - category: NP/NP
#   rule: ADNext
#   semantics: \S Q N F. Q(\G.N(\x.(G(x) & (S(\x v T.(T(v) = x), \x v T.(T(v) = x), \J v.(J(v) & ((Top(v) = x))))))), F)
#   child0_any_category: S\NP

# NP ==> S/S
- category: S/S
  rule: ADV0
  semantics: \Q S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & Q(\I.I,\x.Mod(x,v2))),v1))
  # semantics: \Q S C1 C2 K. S(C1,C2,K)
  child0_category: NP

# S ==> S/S
- category: S/S
  rule: ADV0
  semantics: \S1 S2 C1 C2 K. (S1(C1,C2,K) & S2(C1,C2,K))
  child0_category: S


##### Binary lexical rules for quantifier #####

- category: NP/NP
  rule: <
  semantics: \L R Q N F. forall x.(Q(\G.N(\y.(G(y) & (x = y))), \y.True) -> F(x))
  child0_surf: すべて
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q N F. forall x.(Q(\G.N(\y.(G(y) & (x = y))), \y.True) -> F(x))
  child0_surf: 各々
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q N F. forall x.(Q(\G.N(\y.(G(y) & (x = y))), \y.True) -> F(x))
  child0_surf: それぞれ
  child1_surf: の

# L:NP, R:(S/S)\NP も
- category: S/S
  rule: <
  semantics: \Q R S C1 C2 K. forall x.(Q(\I.I, \y.(x = y)) -> S(C1,C2,\J v1.K(\v2.(J(v2) & (Top(v2) = x)),v1)))
  child0_any_surf: どちら
  child1_surf: も

- category: NP
  rule: <
  semantics: \Q R N F. forall x.(Q(\G.N(\y.(G(y) & (y = x))),\x.True) -> F(x))
  child0_any_surf: どちら
  child1_surf: も
  # jsem-245
  # RT:jsem-245は否定のスコープがうまくいかない

- category: NP
  rule: <
  semantics: \Q R N F. forall x.(Q(\G.N(\y.(G(y) & (y = x))),\x.True) -> F(x))
  child0_any_surf: どの
  child1_surf: も 
  # jsem 128, 321, 337
  # RT:jsem-337は否定のスコープに失敗

- category: NP
  rule: <
  semantics: \Q R N F. forall x.(Q(\G.N(\y.(G(y) & (y = x))),\x.True) -> F(x))
  child0_any_surf: 誰
  child1_surf: も

- category: NP
  rule: <
  semantics: \Q R N F. forall x.(Q(\G.N(\y.(G(y) & (y = x))),\x.True) -> F(x))
  child0_any_surf: 何
  child1_surf: も

- category: NP/NP
  rule: <
  semantics: \L R Q N F. Most(\x.(Q(\G.N(\y.(G(y) & (y = x))), \x.True)), F)
  child0_surf: ほとんど
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q N F. Most(\x.(Q(\G.N(\y.(G(y) & (y = x))), \x.True)), F)
  child0_surf: たいてい
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q N F. Most(\x.(Q(\G.N(\y.(G(y) & (y = x))), \x.True)), F)
  child0_surf: 多く
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q N F. Most(\x.(Q(\G.N(\y.(G(y) & (y = x))), \x.True)), F)
  child0_surf: たくさん
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q N F. Most(\x.(Q(\G.N(\y.(G(y) & (y = x))), \x.True)), F)
  child0_surf: 大勢
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q. Q
  child0_surf: 誰
  child1_surf: か

- category: NP
  rule: <
  semantics: \L R N F. Most(\x.N(\y.True,x),F)
  child0_surf: ほとんど
  child1_surf: が

- category: S
  rule: ">"
  semantics: \L R C1 C2 K1. Most(\x.L(\C3 C4 K2.exists v1.K2(\v2.(Top(v2) = x),v1), C1, C2, \I.I), \x.exists v3.K1(\v4.(Top(v4) = x),v3))
  child0_category: S/S
  child1_surf: ほとんど
  # jsem-79,82

# NCQ-quantifier (floating quantifier)
- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. Most(\y.Q(\I.I,\x.(x = y)), \y.V1(\F1 F2.F2(y),C1,C2,K))
  # semantics: \L V1 Q C1 C2 K. Most(\y.Q(\G x.(G(y) & (x = y)),\x.True), \y.V1(\F1 F2.F2(y),C1,C2,K))
  child0_any_surf: ほとんど
  child0_category: S/S
  # 学生がほとんど来た

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. Most(\y.Q(\I.I,\x.(x = y)), \y.V1(\F1 F2.F2(y),C1,C2,K))
  child0_any_surf: たくさん
  child0_category: S/S

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. forall y.(Q(\I.I,\x.(x = y)) -> V1(\F1 F2.F2(y),C1,C2,K))
  child0_any_surf: 全員
  child0_category: S/S

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. forall y.(Q(\I.I,\x.(x = y)) -> V1(\F1 F2.F2(y),C1,C2,K))
  child0_any_surf: みな
  child0_category: S/S

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. forall y.(Q(\I.I,\x.(x = y)) -> V1(\F1 F2.F2(y),C1,C2,K))
  child0_any_surf: すべて
  child0_category: S/S

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. forall y.(Q(\I.I,\x.(x = y)) -> V1(\F1 F2.F2(y),C1,C2,K))
  child0_any_surf: それぞれ
  child0_category: S/S

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. forall y.(Q(\I.I,\x.(x = y)) -> V1(\F1 F2.F2(y),C1,C2,K))
  child0_any_surf: どちら # not work
  child0_any_surf: も
  child0_category: S/S
  # jsem-252,369

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. forall y.(Q(\I.I,\x.(x = y)) -> V1(\F1 F2.F2(y),C1,C2,K))
  #child0_any_surf: 二
  child0_any_surf: とも
  child0_category: S/S

- category: S/S
  rule: ">B"
  # semantics: \M R S C1 C2 K1. forall v. (M(\D1 D2 K2.K2(\w.True,v),\x v T.(T(v) = x),\x v T.(T(v) = x),\I.I) -> S(C1,C2,\J v1.K1(\v2.(Top(v2) = Top(v)),v1)))
  # semantics: \M R S C1 C2 K1. forall v. (M(\D1 D2 K2.K2(\w.True,v),\x v T.(T(v) = x),\x v T.(T(v) = x),\I.I) -> S(C1,C2,\J v1.K1(\v2.(v2 = v),v1)))
  semantics: \M R S C1 C2 K1. forall x. (M(\R1 R2 K2. exists v1.K2(\v2.(Top(v2) = x),v1), TrueP, TrueP, \I.I) -> S(C1,C2,\J v1.K1(\v2.(Top(v2) = x),v1)))
  child0_category: S/S
  child1_category: S/S
  child1_surf: みな

- category: S/S
  rule: ">B"
  semantics: \M R S C1 C2 K1. forall x. (M(\R1 R2 K2. exists v1.K2(\v2.(Top(v2) = x),v1), TrueP, TrueP, \I.I) -> S(C1,C2,\J v1.K1(\v2.(J(v2) & (Top(v2) = x)),v1)))
  child0_category: S/S
  child1_category: S/S
  child1_any_base: どちら
  child1_any_surf: も
  # jsem-102

- category: S/S
  rule: ">B"
  semantics: \M R S C1 C2 K1. forall x. (M(\R1 R2 K2. exists v1.K2(\v2.(Top(v2) = x),v1), TrueP, TrueP, \I.I) -> S(C1,C2,\J v1.K1(\v2.(J(v2) & (Top(v2) = x)),v1)))
  child0_category: S/S
  child1_category: S/S
  child1_any_pos2: 助数詞
  child1_any_surf: とも
  # jsem-103 二人とも

# - category: S/S
#   rule: ">B"
#   semantics: \M R S C1 C2 K1. forall x. (M(\R1 R2 K2. exists v1.K2(\v2.(Top(v2) = x),v1), TrueP, TrueP, \I.I) -> S(C1,C2,\J v1.K1(\v2.(Top(v2) = x),v1)))
#   # semantics: \M R S C1 C2 K1. forall x. (M(\R1 R2 K2. exists v. (K2(v) & (Top(v) = x)), TrueP, TrueP, \w.TrueP) -> S(C1,C2,\v.((Top(v) = x) & K1(v))))
#   child0_category: S/S
#   child1_category: S/S
#   child1_pos2="助数詞"
#   child1_surf: とも

- category: S/S
  rule: <
  semantics: \L R S. S
  child0_surf: 誰
  child1_surf: か

# 「誰も〜ない」用。あとから否定がつくので何もしないようidにする
- category: S/S
  rule: <
  semantics: \L R S. S
  child0_surf: 誰
  child1_surf: も

- category: S/S
  rule: <
  semantics: \L R S. S
  child_any_surf: 一
  child_any_pos2: 助数詞
  child1_surf: も

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. Few(\x.Q(\I.I, \y.(y = x)))
  child0_surf: ほとんど
  child0_category: S/S
  child1_category: S\NP
  child1_any_base: いる
  # child1_any_base: ない
  # ほとんどいない jsem-93 etc

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. Few(\x.Q(\I.I, \y.(y = x)))
  child0_surf: めったに
  child0_category: S/S
  child1_category: S\NP
  child1_any_base: いる
  child1_any_base: ない
  # めったにいない jsem-94 etc

- category: S\NP
  rule: ">Bx1"
  semantics: \L V1 Q C1 C2 K. Few(\x.Q(\I.I, \y.(y = x)))
  child0_surf: せいぜい
  child0_category: S/S
  child1_category: S\NP
  child1_any_pos2: 助数詞
  child1_any_base: だ
  # せいぜいN人だ jsem-250 etc

# - category: S\NP
#   rule: ">Bx1"
#   semantics: \L V1 Q C1 C2 K. Few(\x.Q(\I.I, \y.(y = x)))
#   child0_category: S/S
#   child0_any_surf: 多く
#   child0_any_surf: て
#   child0_any_surf: も
#   child1_category: S\NP
#   child1_any_pos2: 助数詞
#   child1_any_base: だ
  # 多くてもN人だ jsem-310 etc

# - category: S\NP
#   rule: ">Bx1"
#   semantics: \L V1 Q C1 C2 K. Few(\x.Q(\I.I, \y.(y = x)))
#   child0_category: S/S
#   child0_any_surf: 最大
#   child0_any_surf: で
#   child0_any_surf: も
#   child1_category: S\NP
#   child1_any_pos2: 助数詞
#   child1_any_base: だ
#   # 最大でもN人だ jsem-252 etc


##### Binary lexical rules for negation #####

- category: S\NP
  rule: <B1
  semantics: \V1 R Q1 C1 C2 K. -Q1(\I.I, \x.V1(\F1 F2.F2(x),C1,C2,K)) # wide scope
  # semantics: \V1 R Q1 C1 C2 K. Q1(\I.I, \x.-V1(\F1 F2.F2(x),C1,C2,K)) # narrow scope
  child0_category: S\NP
  child1_base: ない
  # jsem-101 wide scope
  # jsem-52 narrow scope

- category: (S\NP)\NP
  rule: <B2
  semantics: \V2 R Q1 Q2 C1 C2 K. Q2(\I.I,\x.-Q1(\I.I,\y.V2(\F1 F2.F2(y),\G1 G2.G2(x),C1,C2,K))) # intermediate scope
  # semantics: \V2 R Q1 Q2 C1 C2 K. Q2(\I.I,\x.Q1(\I.I,\y.-V2(\F1 F2.F2(y),\G1 G2.G2(x),C1,C2,K))) # narrow scope
  child0_category: (S\NP)\NP
  child1_base: ない

# - category: S\NP
#   rule: <B1
#   semantics: \V2 R Q1 C1 C2 K. -V2(Q1, C1, C2, K)
#   child0_base: 有り得る


##### Binary lexical rules for voice #####

- category: (S\NP[case=ga])\NP[case=ni]
  rule: <B2
  semantics: \V2 R Q1 Q2 C1 C2 K. V2(Q1,Q2,\x v T.C1(x,v,Acc),\x v T.C2(x,v,Top),K)
  child0_category: (S\NP[case=ga])\NP[case=ni]
  child1_base: れる ## S\S
  # jsem-707,709

- category: (S\NP[case=ga])\NP[case=o]
  rule: <B2
  semantics: \V2 R Q1 Q2 C1 C2 K. V2(Q1,Q2,\x v T.C1(x,v,Acc),\x v T.C2(x,v,Acc),K)
  child0_category: (S\NP[case=ga])\NP[case=o]
  child1_base: れる ## S\S
  # jsem-714
  # Adhoc rule

- category: S\NP[case=ga]
  rule: <B1
  semantics: \V1 R Q C1 C2 K. V1(Q,\x v T.C1(x,v,Acc),C2,K)
  child0_category: S\NP[case=ga]
  child1_base: れる


############### Semantic Templates  #################

##### Templates for NPs  #####

- category: NP
  semantics: \E N F. exists x.(N(E,x) & F(x))
  # semantics: \E F1 F2. exists x.(E(x) & F1(x) & F2(x))
  coq_type: Entity -> Prop

##### Templates for NP modifier #####

- category: NP/NP
  semantics: \E Q N F. Q(\G x. N(\y.(E(y) & G(y)),x), F)
  # semantics: \E Q F1 F2. Q(\x.(E(x) & F1(x)), F2)
  coq_type: Entity -> Prop

- category: NP\NP
  semantics: \E Q N F. Q(\G x. N(\y.(E(y) & G(y)),x), F)
  # semantics: \E Q N F. Q(\G x. N(\y.(G(y) & exists z.(E(z) & (z = y))),x), F)
  coq_type: Entity -> Prop
 
##### Templates for VP modifier #####

- category: S/S
  semantics: \E S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & E(v2)),v1))
  # semantics: \E S C1 C2 K. S(C1,C2,\v.(E(v) & K(v)))
  coq_type: Event -> Prop

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & E(v2)),v1))
  # semantics: \E S C1 C2 K. S(C1,C2,\v.(E(v) & K(v)))
  coq_type: Event -> Prop

- category: (S/S)\NP
  # semantics: \E Q S C1 C2 K. Q(\I.I, \x.S(C1,C2,\J v1.K(\v2.(J(v2) & E(v2,x)),v1))) # wide scope
  semantics: \E Q S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & Q(\I.I, \x.E(v2,x))),v1)) # narrow scope jsem-245-247
  coq_type: Event -> Entity -> Prop


##### Templates for adjectives #####

- category: S
  semantics: \E C1 C2 K. exists v.K(E,v)
  coq_type: Event -> Prop
  # semantics: \E C1 C2 K. exists v.(E(v) & K(v))
  # S[form=da], S[form=stem], S[form=s]
  # jsem-130 自由（に）, jsem-155 予定, # jsem-724 遊ば

- category: (S/S)\S
  semantics: \E S1 S2 C1 C2 K. S2(C1,C2,\J v1.K(\v2.(J(v2) & S1(\x v T.(T(v) = x),\x v T.(T(v) = x),\J v3.(J(v3) & (v3 = v2)))),v1))
  # semantics: \E S1 S2 C1 C2 K. S2(C1,C2,\v2.(S1(\x v T.(T(v) = x),\x v T.(T(v) = x),\v1.(v1 = v2)) & K(v2)))
  # coq_type: Event -> Entity -> Prop
  # pos1: 副詞化
  # base: に
  # S1のC1, C2はリセットしてよい？
  # jsem-???

##### Templates for Verb #####

- category: S\NP[case=ga]
  semantics: \E Q C1 C2 K. Q(\I.I, \x.exists v.(K(E,v) & C1(x,v,Top)))
  # semantics: \E Q C1 C2 K. Q(\x.TrueP, \x.exists v.(E(v) & C1(x,v,Top) & K(v)))
  coq_type: Event -> Prop

- category: S\NP[case=o]
  semantics: \E Q C1 C2 K. Q(\I.I, \x.exists v.(K(E,v) & C1(x,v,Acc)))
  # semantics: \E Q C1 C2 K. Q(\x.TrueP, \x.exists v.(E(v) & C1(x,v,Acc) & K(v)))
  coq_type: Event -> Prop

- category: S\NP[case=ni]
  semantics: \E Q C1 C2 K. Q(\I.I, \x.exists v.(K(E,v) & C1(x,v,Dat)))
  # semantics: \E Q C1 C2 K. Q(\x.TrueP, \x.exists v.(E(v) & C1(x,v,Dat) & K(v)))
  coq_type: Event -> Prop

- category: S\NP[case=to]
  semantics: \E Q C1 C2 K. exists v.(K(E,v) & AccI(v,Q(\x.True, \x.True)))
  coq_type: Event -> Prop

- category: (S\NP[case=ga])\NP[case=o]
  semantics: \E Q2 Q1 C1 C2 K. Q1(\I.I, \x1.Q2(\I.I, \x2.exists v.(K(E,v) & C1(x1,v,Top) & C2(x2,v,Acc))))
  # semantics: \E Q2 Q1 C1 C2 K. Q1(\x1.TrueP, \x1.Q2(\x2.TrueP, \x2.exists v.(E(v) & C1(x1,v,Top) & C2(x2,v,Acc) & K(v))))
  coq_type: Event -> Prop

- category: (S\NP[case=ga])\NP[case=ni]
  semantics: \E Q2 Q1 C1 C2 K. Q1(\I.I, \x1.Q2(\I.I, \x2.exists v.(K(E,v) & C1(x1,v,Top) & C2(x2,v,Dat))))
  # semantics: \E Q2 Q1 C1 C2 K. Q1(\x1.TrueP, \x1.Q2(\x2.TrueP, \x2.exists v.(E(v) & C1(x1,v,Top) & C2(x2,v,Dat) & K(v))))
  coq_type: Event -> Prop

- category: (S\NP[case=o])\NP[case=ga]
  semantics: \E Q1 Q2 C1 C2 K. Q1(\I.I, \x1.Q2(\I.I, \x2.exists v.(K(E,v) & C1(x1,v,Top) & C2(x2,v,Acc))))
  # semantics: \E Q1 Q2 C1 C2 K. Q1(\x1.TrueP, \x1.Q2(\x2.TrueP, \x2.exists v.(E(v) & C1(x1,v,Top) & C2(x2,v,Acc) & K(v))))
  coq_type: Event -> Prop

- category: (S\NP[case=ni])\NP[case=ga]
  semantics: \E Q1 Q2 C1 C2 K. Q1(\I.I, \x1.Q2(\I.I, \x2.exists v.(K(E,v) & C1(x1,v,Top) & C2(x2,v,Dat))))
  # semantics: \E Q1 Q2 C1 C2 K. Q1(\x1.TrueP, \x1.Q2(\x2.TrueP, \x2.exists v.(E(v) & C1(x1,v,Top) & C2(x2,v,Dat) & K(v))))
  coq_type: Event -> Prop

- category: (S\NP[case=o])\NP[case=ni]
  semantics: \E Q1 Q2 C1 C2 K. Q1(\I.I, \x1.Q2(\I.I, \x2.exists v.(K(E,v) & C1(x1,v,Dat) & C2(x2,v,Acc))))
  # semantics: \E Q1 Q2 C1 C2 K. Q1(\x1.TrueP, \x1.Q2(\x2.TrueP, \x2.exists v.(E(v) & C1(x1,v,Dat) & C2(x2,v,Acc) & K(v))))
  coq_type: Event -> Prop

- category: (S\NP[case=ga])\NP[case=to]
  semantics: \E Q2 Q1 C1 C2 K. Q1(\I.I, \x.exists v.(K(E,v) & C1(x,v,Top) & AccI(v,Q2(\I.I,\x.True))))
  # semantics: \E Q2 Q1 C1 C2 K. Q1(\x.TrueP, \x.exists v.(E(v) & C1(x,v,Top) & AccI(v,Q2(\x.TrueP,\x.TrueP)) & K(v)))
  coq_type: Event -> Prop
  # jsem-778

- category: (S[form=da]\NP[case=ga])\NP
  semantics: \E Q1 Q2 C1 C2 K. Q2(\I.I, \x1.Q1(\I.I, \x2.exists v.(K(E,v) & C1(x1,v,Top) & C2(x2,v,Attr))))
  # semantics: \E Q1 Q2 C1 C2 K. Q2(\x1.TrueP, \x1.Q1(\x2.TrueP, \x2.exists v.(E(v) & C1(x1,v,Top) & C2(x2,v,Attr) & K(v))))
  coq_type: Event -> Prop
  # jsem50, 的

- category: ((S\NP[case=ga])\NP[case=to])\NP[case=o]
  semantics: \E Q1 Q2 Q3 C1 C2 K. (Q3(\I.I, \x1.Q1(\I.I, \x3.exists v.(K(E,v) & C1(x1,v,Top) & AccI(v,Q2(\I.I,\x2.True)) & C2(x3,v,Acc)))))
  coq_type: Event -> Prop
  # semantics: \E Q1 Q2 Q3 C1 C2 K. (Q3(\I.I, \x1.Q1(\I.I, \x3.exists v.(K(E,v) & C1(x1,v,Top) & AccI(v,Q2(\I.I,\x2.True)) & C2(x3,v,Acc)))))
  # semantics: \E Q1 Q2 Q3 C1 C2 K. (Q3(\I.I, \x1.Q1(\I.I, \x3.exists v.(K(E,v) & C1(x1,v,Top) & AccI(v,Q2(\I.I,\x2.True)) & C2(x3,v,Acc)))) & Q2(\I.I,\x2.True))
  # semantics: \E Q1 Q2 Q3 C1 C2 K. (Q3(\x1.TrueP, \x1.Q1(\x3.TrueP, \x3.exists v.(E(v) & C1(x1,v,Top) & AccI(v,Q2(\x2.TrueP, \x2.TrueP)) & C2(x3,v,Acc) & K(v)))) & Q2(\x2.TrueP, \x2.TrueP))
  # semantics: \E Q1 Q2 Q3 C1 C2 K. Q3(\x1.TrueP, \x1.Q1(\x3.TrueP, \x3.exists v.(E(v) & C1(x1,v,Top) & AccI(v,Q2(\x2.TrueP, \x2.TrueP)) & C2(x3,v,Acc) & K(v))))
  # semantics: \E Q1 Q2 Q3 C1 C2 K. (Q3(\x1.TrueP,\x1.Q1(\x3.TrueP, \x3.exists v.(E(v) & C1(x1,v,Top) & C2(x3,v,Acc) & K(v)))) & Q2(\x2.TrueP, \x2.TrueP))

##### Templates for particles #####

- category: (NP/NP)\S
  semantics: \E S Q N F. Q(\G.N(\x.(G(x) & S(\x v T.(T(v) = x),\x v T.(T(v) = x),\J v.(J(v) & (Top(v) = x))))),F)
  # jsem-768 か


############### Lexical entries #################

##### NPs #####

- category: NP
  semantics: \E N F. (N(\x.True,E) & F(E))
  # semantics: \E F1 F2. (F1(E) & F2(E))
  coq_type: Entity
  pos1: 固有名詞
  pos2: 人名

# - category: NP
#   semantics: \E N F. (N(\x.True,E) & F(E))
#   coq_type: Entity
#   pos1: 固有名詞
#   pos2: 地域
# doesn't work for jsem-172 ヨーロッパ

- category: NP/NP
  semantics: \E Q N F. Q(\G x.(N(G,E)), \x.(F(E) & F(x)))
  # semantics: \E Q N F. Q(\G x.(N(G,x) & Rel(x,E)), F)
  # semantics: \E Q F1 F2. Q(\x.(F1(E) & F1(x)), \x.(F2(E) & F2(x)))
  coq_type: Entity
  pos1: 固有名詞
  pos2: 人名
  # jsem-195, 117-123

# - category: NP/NP
#   semantics: \E Q N F. Q(\G x.(N(G,E)), \x.(F(E) & F(x)))
#   coq_type: Entity
#   pos1: 固有名詞
#   pos2: 地域

- category: NP
  semantics: \E N F. (N(\x.True,E) & F(E))
  # semantics: \E F1 F2. (F1(E) & F2(E))
  coq_type: Entity
  pos1: 代名詞

- category: NP/NP
  semantics: \E Q N F. Q(\G x. ((this(G) = x) & N(\x.True, this(G))), F)
  surf: この
  # coq_type: (Entity -> Prop) -> Entity ## does not work!
  # ValueError: Invalid type name: (Entity in Parameter _この : (Entity -> Prop) -> Entity.

- category: NP/NP
  semantics: \E Q N F. Q(\G x. ((that(G) = x) & N(\x.True, that(G))), F)
  surf: あの

- category: NP
  semantics: \E N F. exists x. (N(E,x) & F(x))
  base: こと
  # semantics: \E N F. exists x. (N(\y.True,x) & F(x))
  # semantics: \E N F. E
  # semantics: \E N F. exists x. (N(\y.(x = y),x) & F(x))
  # semantics: \E F1 F2. exists x. (F1(x) & F2(x))
  # coq_type: (Entity -> Prop) -> Prop ## does not work!
  # ValueError: Invalid type name: (Entity in Parameter _こと : (Entity -> Prop) -> Prop.

- category: NP
  semantics: \E N F. exists x. (N(E,x) & F(x))
  # semantics: \E N F. exists x. (N(\y.True,x) & F(x))
  # semantics: \E F1 F2. exists x. (F1(x) & F2(x))
  base: の

- category: NP
  semantics: \E N F. exists x. (N(_人,x) & F(x))
  base: 人々

- category: NP/NP
  semantics: \E Q N F. Q(\G.N(\x.(G(x) & _人(x))), F)
  base: 人々

- category: NP\NP
  semantics: \E Q N F. Q(N,F)
  base: たち

- category: NP\NP
  semantics: \E Q N F. Q(N,F)
  base: 達

##### NP modifier #####

- category: (NP/NP)\NP
  semantics: \E Q1 Q2 N F. Q2(\G z. N(\y.(Q1(\I.I, \x.(y = x)) & G(y)), z), F)
  # semantics: \E Q1 Q2 F1 F2. Q2(\y.(Q1(\x.TrueP, \x.(y = x)) & F1(y)), F2)
  base: の
  
- category: (NP/NP)\NP
  semantics: \E Q1 Q2 N F. Q2(\G z. N(\y.(Q1(\I.I, \x.(E(x) & (y = x))) & G(y)), z), F)
  # semantics: \E Q1 Q2 F1 F2. Q2(\y.(Q1(\x.TrueP, \x.(E(x) & (x = y))) & F1(y)), F2)
  pos1: 接尾
  coq_type: Entity -> Prop

- category: (NP/NP)\S
  semantics: \E S Q N F. Q(\G.N(\x.(G(x) & S(\x v T.(T(v) = x),\x v T.(T(v) = x),\J v.(J(v) & (Top(v) = x))))),F)
  # semantics: \E S Q F1 F2. Q(\x.(S(\x v T.(T(v) = x),\x v T.(T(v) = x),\v.(Top(v) = x)) & F1(x)), F2)
  base: の
  # jsem-155

- category: (S/S)\NP
  semantics: \E Q S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & Q(\I.I, \x.((Top(v2) = x)))),v1))
  # semantics: \E Q S C1 C2 K. S(C1, C2, \v.Q(\x.TrueP, \x.((Top(v) = x) & K(v))))
  base: の
  # jsem-79,82,174

- category: NP\S
  semantics: \E S N F. S(\x v T.(T(v) = x), \x v T.(T(v) = x), \J v1.exists x.(J(v1) & (Top(v1) = x) & F(x)))
  # semantics: \E S F1 F2. S(\x v T.(T(v) = x), \x v T.(T(v) = x), \J v1.exists x.(J(v1) & (Top(v1) = x) & F2(x)))
  # semantics: \E S F1 F2. S(\x v T.(T(v) = x), \x v T.(T(v) = x), \v.exists x.((Top(v) = x) & F2(x)))
  base: が  
  # jsem-79,82,174

- category: (S/S)\S
  semantics: \E S1 S2 C1 C2 K. S1(\x v T.(T(v) = x), \x v T.(T(v) = x), \J1 v1.K(\v2.(J1(v2) & S2(C1,C2,\J2 v3.(J2(v3) & (Top(v3) = Top(v2))))),v1))
  # semantics: \E S1 S2 C1 C2 K. S1(\x v T.(T(v) = x), \x v T.(T(v) = x), \v1.S2(C1,C2,\v2.((Top(v2) = Top(v1)) & K(v))))
  base: は
  # jsem-174

- category: (S/S)\S
  semantics: \E S1 S2 C1 C2 K. S2(C1,C2,\J v1.K(\v2.(J(v2) & AccI(v2,S1(\x v T.(T(v) = x),\x v T.(T(v) = x),\I.I))),v1))
  # semantics: \E S1 S2 C1 C2 K. S2(C1,C2,\J v1.K(\v2.(J(v2) & S1(\x v T.(T(v) = x),\x v T.(T(v) = x),\J v3.(J(v3) & (v3 = v2)))),v1))
  # semantics: \E S1 S2 C1 C2 K. S2(C1,C2,\v2.(S1(\x v T.(T(v) = x),\x v T.(T(v) = x),\v1.(v1 = v2)) & K(v2)))
  base: という

##### Determiner #####

- category: NP
  semantics: \E N F. forall x.(N(\y.True,x) -> F(x))
  # semantics: \E F1 F2. forall x.(F1(x) -> F2(x))
  base: すべて

- category: NP
  semantics: \E N F. forall x.(N(\y.True,x) -> F(x))
  # semantics: \E F1 F2. forall x.(F1(x) -> F2(x))
  base: 全員

- category: NP
  semantics: \E N F. forall x.(N(\y.True,x) -> F(x))
  # semantics: \E F1 F2. forall x.(F1(x) -> F2(x))
  base: 各々

- category: NP
  semantics: \E N F. forall x.(N(\y.True,x) -> F(x))
  # semantics: \E F1 F2. forall x.(F1(x) -> F2(x))
  base: それぞれ

- category: NP
  semantics: \E N F. exists x.(N(\y.True,x) & F(x))
  # semantics: \E F1 F2. exists x.(F1(x) & F2(x))
  base: 誰か

- category: NP
  semantics: \E N F. Most(\x.N(\y.True,x),F)
  base: ほとんど

- category: NP
  semantics: \E N F. Most(\x.N(\y.True,x),F)
  base: 多く

- category: NP
  semantics: \E N F. exists x.(N(\y.True,x) & F(x))
  # semantics: \E F1 F2. exists x.(F1(x) & F2(x))
  base: 誰

- category: NP
  semantics: \E N F. exists x.(N(\y.True,x) & F(x))
  # semantics: \E F1 F2. exists x.(F1(x) & F2(x))
  base: 何

- category: NP
  semantics: \E N F. exists x.(N(\y.True,x) & F(x))
  base: どちら

- category: NP/NP
  semantics: \E Q. Q
  base: ある

- category: NP/NP
  semantics: \E Q N F. forall x.(Q(\G.N(\y.(G(y) & (x = y))), \y.TrueP) -> F(x))
  # semantics: \E Q F1 F2. forall x.(Q(\y.(F1(x) & (x = y)), \y.TrueP) -> F2(x))
  base: あらゆる

- category: NP/NP
  semantics: \E Q N F. forall x.(Q(\G.N(\y.(G(y) & (x = y))), \y.TrueP) -> F(x))
  # semantics: \E Q F1 F2. forall x.(Q(\y.(F1(x) & (x = y)), \y.TrueP) -> F2(x))
  base: 全

- category: NP/NP
  semantics: \E Q N F. forall x.(Q(\G.N(\y.(G(y) & (x = y))), \y.TrueP) -> F(x))
  # semantics: \E Q F1 F2. forall x.(Q(\y.(F1(x) & (x = y)), \y.TrueP) -> F2(x))
  base: 各

- category: NP/NP
  semantics: \E Q N F. Q(N,F)
  # semantics: \E Q F1 F2. Q(F1,F2)
  # semantics: \E Q F1 F2. forall x.(Q(\y.((x = y) & F1(x)), \x.TrueP) -> F2(x))
  base: どの

# - category: NP
#   semantics: \E F1 F2. exists x. (F1(x) & F2(x))
#   base: どちら
#   #jsem-95

- category: NP/NP
  semantics: \E Q N F. forall x.(Q(\G.N(\y.(G(y) & (x = y))), \y.True) -> F(x))
  base: みな
  # semantics: \E Q F1 F2. forall x.(Q(\y.(F1(x) & (x = y)), \y.TrueP) -> F2(x))
  #semantics: \E Q F1 F2. Q(F1,F2)
  # jsem-172?

# 何人か
- category: (NP/NP)\NP
  semantics: \E Q1 Q2 N F. (Q1(N,F) | Q2(N,F))
  base: か
  # jsem-376,377はdisjunction

- category: (S/S)\NP
  semantics: \E Q S C1 C2 K. S(C1,C2,K)
  base: か
  # jsem-155

# 助数詞
- category: NP\NP
  semantics: \E Q. Q
  pos2: 助数詞

##### particles  #####

# case marker
- category: NP\NP
  semantics: \E Q. Q
  pos: 助詞

# - category: NP\NP
#   semantics: \E Q N F. Q(\G x.(N(\y.(G(y) & exists z.E(z,y)),x)), F)
#   coq_type: Entity -> Entity -> Prop
#   base: へ
#   # jsem-178

##- category: NP\NP
##  semantics: \E Q F1 F2. forall x.(Q(\y.(F1(x) & (x = y)), \y.TrueP) -> F2(x))
##  base: も

- category: NP[case=to]\S
  semantics: \E S N F. S(\x v T.(T(v) = x),\x v T.(T(v) = x),\I.I)
  # semantics: \E S F1 F2. S(\x v T.(T(v) = x),\x v T.(T(v) = x),\I.I)
  # jsem-778

- category: NP\S
  semantics: \E S N F. WH(S(\x v T.(T(v) = x),\x v T.(T(v) = x),\I.I))
  # semantics: \E S N F. S(\x v T.(T(v) = x),\x v T.(T(v) = x),\I.I)
  base: か
  # jsem-778

# 「は」は全称量化を導入 cf. jsem-95など
# - category: NP\NP
#   semantics: \E Q F1 F2. (Q(\y.TrueP, \y.TrueP) & forall x.((Q(\y.TrueP, \y.(x = y)) & F1(x)) -> F2(x)))
#   base: は


##### Conjunction #####

- category: (NP/NP)\NP
  semantics: \E Q1 Q2 N F. (Q1(N,F) & Q2(N,F))
  # semantics: \E Q1 Q2 N F. (Q1(\x.N(\y.True,x),F) & Q2(\x.N(\y.True,x),F))
  base: と  

# # eg. 太郎か花子
# - category: (NP/NP)\NP
#   semantics: \E Q1 Q2 F1 F2. (Q1(F1, F2) | Q2(F1, F2))
#   base: か


##### VP modifier #####

- category: S/S
  semantics: \E S. S
  base: 少なくとも
  # jsem-298, 少なくとも

- category: (S/S)\NP
  semantics: \E Q S C1 C2 K. Q(\I.I, \x.S(C1,C2,\J v1.K(\v2.(J(v2) & (Top(v2) = x)),v1)))
  base: が

- category: (S/S)\NP
  # semantics: \E Q S C1 C2 K. Q(\I.I, \x.S(C1,C2,\J v1.K(\v2.(J(v2) & ((Dat(v2) = x))),v1))) # wide scope
  semantics: \E Q S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & Q(\I.I,\x.((Dat(v2) = x)))),v1)) # narrow scope
  # semantics: \E Q S C1 C2 K. S(C1,C2,\v.Q(\x.TrueP, \x.((Dat(v) = x) & K(v)))) for narrow scope
  # semantics: \E Q S K. Q(\x.TrueP, \x.S(\v.((Dat(v) = x) & K(v))))
  coq_type: Event -> Entity -> Prop
  base: に

- category: (S/S)\NP
  semantics: \E Q S C1 C2 K. Q(\I.I, \x.S(C1,C2,\J v1.K(\v2.(J(v2) & (Acc(v2) = x)),v1)))
  # semantics: \E Q S C1 C2 K. Q(\x.TrueP, \x.S(C1,C2,\v.(Acc(v,x) & K(v))))
  coq_type: Event -> Entity -> Prop
  base: を

- category: (S/S)\NP
  semantics: \E Q S C1 C2 K. Q(\I.I, \x.S(C1,C2,\J v1.K(\v2.(J(v2) & (Top(v2) = x)),v1)))
  # semantics: \E Q S C1 C2 K. Q(\x.TrueP, \x.S(C1,C2,\v.((Top(v) = x) & K(v))))
  base: は

- category: (S/S)\NP
  semantics: \E Q S C1 C2 K. Q(\I.I, \x.S(C1,C2,\J v1.K(\v2.(J(v2) & ((Top(v2) = x))),v1)))
  # semantics: \E Q S C1 C2 K. Q(\x.TrueP, \x.S(C1,C2,\v.((Top(v) = x) & K(v))))
  base: として

# 助数詞の扱いと統一すべき？
# 「一人」とかのため。本当は嫌。
- category: (S/S)\NP
  semantics: \E Q S C1 C2 K. Q(\I.I, \x.S(C1,C2,\J v1.K(\v2.(J(v2) & E(x)),v1)))
  # semantics: \E Q S C1 C2 K. Q(\x.TrueP, \x.S(C1,C2,\v.(E(x) & K(v))))
  coq_type: Entity -> Prop
  base: 人

# 「自由+に」
# - category: S/S
#   semantics: \L R S K. S(\v.(L(v) & K(v)))
#   child0_category: S
#   child1_category: (S/S)\S
#   child1_pos1: "副詞化"
# 「は」の係り方はこれに則らない。「学生のほとんどは来た」に失敗するため(cf. jsem295)

- category: (S/S)\NP
  semantics: \E Q S C1 C2 K. forall x. (S(C1,C2,\J v1.K(\v2.(J(v2) & (Top(v2) = x)),v1)) | Q(\I.I, \y.(x = y)))
  # semantics: \E Q S C1 C2 K. forall x. (Q(\I.I, \y.(x = y)) | S(C1,C2,\J v1.K(\v2.(J(v2) & (Top(v2) = x)),v1)))
  base: しか

- category: (S/S)\S
  semantics: \E S1 S2 C1 C2 K. (S1(\x v T.(T(v) = x),\x v T.(T(v) = x),\I.I) -> S2(C1,C2,K))
  # semantics: \E S1 S2 C1 C2 K. (S1(\x v T.(T(v) = x),\x v T.(T(v) = x),\J v3.(J(v3) & (v3 = v2))) -> S2(C1,C2,\J v1.K(\v2.J(v2),v1)))
  # semantics: \E S1 S2 C1 C2 K. S2(C1,C2,\J v1.K(\v2.(J(v2) & S1(\x v T.(T(v) = x),\x v T.(T(v) = x),\J v3.(J(v3) & (v3 = v2)))),v1))
  base: ば

## intensional VP-operators

- category: S/S
  semantics: \E S C1 C2 K. S(C1,C2,\J v.K(E(J),v))
  base: ほぼ

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,\J v.K(E(J),v))
  base: 損ねる
  # jsem-755

##### Privative adjectives #####

- category: NP/NP
  rule: <
  semantics: \L R Q N F. Q(\G x. N(_fake(G),x), F)
  # semantics: \L R Q F1 F2. _fake(Q(F1,F2))
  child0_surf: 偽物
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q N F. Q(\G x. (N(_一流(G),x) & N(G,x)), F)
  # semantics: \L R Q N F. Q(\G x. N(_一流(G),x), F)
  child0_surf: 一流
  child1_surf: の

- category: NP/NP
  rule: <
  semantics: \L R Q N F. Q(\G x. N(_former(G),x), F)
  # semantics: \L R Q F1 F2. _former(Q(F1,F2))
  child0_surf: かつて
  child1_surf: の

- category: NP/NP
  semantics: \E Q N F. Q(\G x. N(E(G),x), F)
  # semantics: \E Q F1 F2. E(Q(F1,F2))
  coq_type: Prop -> Prop
  surf: 自称

- category: NP/NP
  semantics: \E Q N F. Q(\G x. N(_former(G),x), F)
  # semantics: \E Q F1 F2. _former(Q(F1,F2))
  surf: 元


##### Verb #####

- category: S\NP[case=ga]
  semantics: \E Q C1 C2 K. Q(\I.I, \x.True)
  # semantics: \E Q K. Q(\x.TrueP, K)
  # semantics: \E Q K. Q(\x.TrueP, \x.exists v. ((Acc(v) = x) & K(v)))
  base: いる

- category: S\NP[case=ga]
  semantics: \E Q C1 C2 K. Q(\I.I, \x.True)
  base: ある
  #####
  # semantics: \E Q K. Q(\x.TrueP, \x.exists v. ((Acc(v) = x) & K(v)))
  # works for jsem-104, but not for jsem-1 etc.
  # jsem-104

- category: S\NP[case=ga]
  semantics: \E Q C1 C2 K. -Q(\I.I, \x.True)
  # semantics: \E Q K. -Q(\x.TrueP, \x.exists v.((Acc(v) = x) & K(v)))
  # semantics: \E Q C1 C2 K. -Q(\x.TrueP, \x.exists v.(C1(x,v,Acc) & K(v)))
  base: ない
  # works for jsem-104, but not for jsem-1 etc.
  # jsem-104

#- category: S\NP
#  semantics: \L R Q C1 C2 K. exists v.(K(Poss,v) & AccI(v,Q(\I.I, \x.True)))
#  child0_base: ある
#  child1_base: うる
#  # jsem-787

#- category: S\NP
#  semantics: \E Q C1 C2 K. exists v.(K(Poss,v) & AccI(v,Q(\I.I, \x.True)))
#  base: ありえる
#  coq_type: Event -> Prop
#  # jsem-786

- category: S\NP
  semantics: \E Q C1 C2 K. exists v.(K(Poss,v) & AccI(v,Q(\I.I, \x.True)))
  base: 有り得る
  coq_type: Event -> Prop
  # jsem-785, 787

#- category: S\NP
#  semantics: \L R Q C1 C2 K. Q(\I.I,\x.exists v.(K(NonPoss,v) & C1(x,v,Top)))
#  # semantics: \L R Q C1 C2 K. exists v.(K(NonPoss,v) & AccI(v,Q(\I.I, \x.True)))
#  child0_base: ありえる
#  child1_base: ない
#  # jsem-786

- category: S\NP
  semantics: \L R Q C1 C2 K. Q(\I.I,\x.exists v.(K(NonPoss,v) & C1(x,v,Top)))
  # semantics: \L R Q C1 C2 K. exists v.(K(NonPoss,v) & AccI(v,Q(\I.I, \x.True)))
  child0_base: 有り得る
  child1_base: ない
  # jsem-786

# - category: (S\NP[case=ga])\NP[case=o]
#   semantics: \E Q2 Q1 C1 C2 K. Q1(\I.I, \x.exists v.(K(E,v) & C1(x,v,Top) & AccI(v,Q2(\I.I,\x.True))))
#   coq_type: Event -> Prop
#   base: 疑う
#   # jsem-780

### Copula ###

# 「だ」2-place
- category: (S\NP[case=ga])\NP
  semantics: \E Q1 Q2 C1 C2 K. Q2(\I.I, \x.exists v.(C1(x,v,Top) & Q1(\I.I,\y.(y = x)) & K(\w.True,v)))
  base: だ

# 「だ」1-place
- category: S\NP
  semantics: \E Q C1 C2 K. Q(\I.I, \x.exists v.(C1(x,v,Top) & K(\w.True,v)))
  base: だ

# 「偉大な」の「な」など、形容動詞の「な」だけemptyにしたい
- category: S\S
  semantics: \E S. S
  base: だ
  # surf: な
  # base: だ
  # jsem-18など

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,K)
  # semantics: \E S C1 C2 K. S(C1,C2,\v.(Past(v) & K(v)))
  surf: だ
  # base: だ
  # jsem-714, 「盗んだ」の「だ」

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & Past(v2)),v1))
  # semantics: \E S C1 C2 K. S(C1,C2,\v.(Past(v) & K(v)))
  surf: た

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,K)
  surf: て

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,K)
  base: いる

# - category: S\NP
#   rule: "<B1"
#   semantics: \L R. L
#   child0_pos1: "形容動詞語幹"
#   child1_category: S\S
#   child1_surf: な

- category: S
  semantics: \E C1 C2 K. exists v.K(E,v)
  # semantics: \E C1 C2 K. exists v.(E(v) & K(v))
  coq_type: Event -> Prop
  base: だ

- category: (S\NP[case=ga])\NP
  semantics: \E Q1 Q2 C1 C2 K. Q2(\I.I, \x.exists v.(C1(x,v,Top) & Q1(\I.I,\y.(y = x)) & K(\w.True,v)))
  # semantics: \E Q1 Q2 C1 C2 K. Q2(\x.TrueP, \x.exists v.(C1(x,v,Top) & Q1(\y.(y = x), \y.TrueP) & K(v)))
  base: は
  # 犯人ではないの「は」, copulaの「だ」と同じはたらき
  # jsem-778

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,K)
  base: ある

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,K)
  base: は

- category: S\S
  semantics: \E S C1 C2 K. -S(C1,C2,K)
  base: ない

- category: S
  semantics: \E C1 C2 K. exists v.K(E,v)
  # semantics: \E C1 C2 K. exists v.(E(v) & K(v))
  coq_type: Event -> Prop
  pos1: "サ変接続"

- category: S/S
  semantics: \E S C1 C2 K. S(C1,C2,K)
  base: もし

### Voice ###

- category: S\S
  semantics: \E S. S
  base: れる
  # jsem-707,709

- category: S\S
  semantics: \E S C1 C2 K. S(C1,C2,\J v1.K(\v2.(J(v2) & E(v2)),v1))
  # semantics: \E S C1 C2 K. S(C1,C2,\v.(E(v) & K(v)))
  base: せる
  # jsem-722,723

##### Punctuation #####

- category: (NP/NP)\(NP/NP)
  semantics: \E X. X
  base: 、

- category: NP\NP
  semantics: \E X. X
  base: 、

- category: S\S
  semantics: \E X. X
  base: 、

- category: (S/S)\(S/S)
  semantics: \E X. X
  base: 、

- category: S\S
  semantics: \E S. S(\x v T.(T(v) = x), \x v T.(T(v) = x), \I.I)
  # semantics: \E S. S(\x v T.(T(v) = x), \x v T.(T(v) = x), \x.TrueP)
  base: 。

