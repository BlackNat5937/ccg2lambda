package visualization.utils.formula;

import visualization.Main;
import visualization.utils.formula.node.Actor;
import visualization.utils.formula.node.Conjunction;
import visualization.utils.formula.node.Event;
import visualization.utils.formula.node.Negation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 * Represents a formula output by ccg2lambda.
 * Also encapsulates the base lambda and the sentence said lambda was generated from.
 *
 * @author Ga√©tan Basile
 */
public class Formula {
    /**
     * The base formula this formula was created from.
     */
    private String lambda;
    /**
     * The sentence which is represented by this formula.
     */
    private String sentence;
    /**
     * The actors of this formula. They are the ones to initiate or to endure events.
     */
    private Map<String, Actor> actors = new HashMap<>();
    /**
     * The events of this formula. They represent actions and have effect on the actors.
     */
    private Map<String, Event> events = new HashMap<>();
    /**
     * The conjunctions of this formula. They link other items or provide additionnal info (time, place...)
     */
    private Map<String, Conjunction> conjunctions = new HashMap<>();

    /**
     * THe negation of this formula.
     */
    private ArrayList<Negation> negations = new ArrayList<>();

    /**
     * Private constructor for a formula, they must be created using the formula parser.
     * See {@link ClassicParser}
     */
    Formula() {
    }

    /**
     * Private constructor for a formula. Initializes the lambda and sentence fields.
     *
     * @param lambda   the formula generated by ccg2lambda
     * @param sentence the base sentence the lambda was generated from
     */
    Formula(String lambda, String sentence) {
        this.lambda = lambda;
        this.sentence = sentence;
    }

    public static FormulaParser getParser() {
        FormulaParser parser = null;
        switch (Main.selectedParserType) {
            case CLASSIC:
                parser = new ClassicParser();
                break;
            case EVENT:
                parser = new EventParser();
                break;
        }
        return parser;
    }

    /**
     * Get the key to an actor by searching for its name.
     *
     * @param name the name of the actor we search for.
     * @return the key if found; null otherwise
     */
    String getActorByName(String name) {
        for (Map.Entry<String, Actor> entry : actors.entrySet()) {
            if (entry.getValue().getName().equals(name)) {
                return entry.getKey();
            }
        }
        return null;
    }

    /**
     * Get the base lambda for this formula.
     *
     * @return a String containing the base lambda
     */
    public String getLambda() {
        return lambda;
    }

    /**
     * Get the sentence this formula was made from.
     *
     * @return a String containing the base sentence
     */
    public String getSentence() {
        return sentence;
    }

    /**
     * Get the actors of the formula.
     *
     * @return a map containing all the actors by id->value
     */
    public Map<String, Actor> getActors() {
        return actors;
    }

    /**
     * Get the events of the formula.
     *
     * @return a map containing all the events by actor_executing_the_event->value
     */
    public Map<String, Event> getEvents() {
        return events;
    }

    /**
     * Get the conjunctions of the formula.
     *
     * @return a map containing all conjunctions by actors_and_events_whom_this_applies->value
     */
    public Map<String, Conjunction> getConjunctions() {
        return conjunctions;
    }

    public ArrayList<Negation> getNegations() {
        return negations;
    }
}
